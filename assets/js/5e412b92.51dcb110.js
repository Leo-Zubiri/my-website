"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8224],{3905:(e,n,a)=>{a.d(n,{Zo:()=>u,kt:()=>f});var r=a(7294);function o(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function i(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,r)}return a}function t(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?i(Object(a),!0).forEach((function(n){o(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function s(e,n){if(null==e)return{};var a,r,o=function(e,n){if(null==e)return{};var a,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],n.indexOf(a)>=0||(o[a]=e[a]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)a=i[r],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var l=r.createContext({}),c=function(e){var n=r.useContext(l),a=n;return e&&(a="function"==typeof e?e(n):t(t({},n),e)),a},u=function(e){var n=c(e.components);return r.createElement(l.Provider,{value:n},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var a=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(a),m=o,f=d["".concat(l,".").concat(m)]||d[m]||p[m]||i;return a?r.createElement(f,t(t({ref:n},u),{},{components:a})):r.createElement(f,t({ref:n},u))}));function f(e,n){var a=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=a.length,t=new Array(i);t[0]=m;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[d]="string"==typeof e?e:o,t[1]=s;for(var c=2;c<i;c++)t[c]=a[c];return r.createElement.apply(null,t)}return r.createElement.apply(null,a)}m.displayName="MDXCreateElement"},4342:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>t,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var r=a(7462),o=(a(7294),a(3905));const i={},t="C# Intro",s={unversionedId:"NET/CSharp",id:"NET/CSharp",title:"C# Intro",description:"Intro",source:"@site/docs/NET/01-CSharp.md",sourceDirName:"NET",slug:"/NET/CSharp",permalink:"/my-website/docs/NET/CSharp",draft:!1,editUrl:"https://github.com/Leo-Zubiri/my-website/tree/master/docs/NET/01-CSharp.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Visual Studio Code",permalink:"/my-website/docs/NET/VSCode"},next:{title:"Backend",permalink:"/my-website/docs/NET/Backend/"}},l={},c=[{value:"Clases",id:"clases",level:2},{value:"Herencia",id:"herencia",level:3},{value:"Sobreescritura / override",id:"sobreescritura--override",level:3},{value:"Interfaces",id:"interfaces",level:2},{value:"Generics",id:"generics",level:2},{value:"Serializacion y deserializacion (JSON)",id:"serializacion-y-deserializacion-json",level:2},{value:"Programacion Funcional",id:"programacion-funcional",level:2},{value:"Funcion Pura",id:"funcion-pura",level:3},{value:"Funcion de primera clase",id:"funcion-de-primera-clase",level:3},{value:"Expresiones Lambda",id:"expresiones-lambda",level:2},{value:"LINQ",id:"linq",level:2}],u={toc:c},d="wrapper";function p(e){let{components:n,...a}=e;return(0,o.kt)(d,(0,r.Z)({},u,a,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"c-intro"},"C# Intro"),(0,o.kt)("p",null,"Conceptos generales necesarios para complementar los conceptos basicos de c#"),(0,o.kt)("h2",{id:"clases"},"Clases"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Las propiedades de la clase se recomienda escribirlas con mayuscula inicial. Ej: ",(0,o.kt)("inlineCode",{parentName:"li"},"public decimal Total;")),(0,o.kt)("li",{parentName:"ul"},"Las propiedades privadas se recomienda escribirlas con guion bajo. Ej: ",(0,o.kt)("inlineCode",{parentName:"li"},"private decimal _myvar;"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c#"},'class Sale{\n    public decimal Total {get; set;}\n    public Sale(){}\n    public Sale(decimal Total){\n        // this hace referencia a la variable de la clase\n        this.Total = Total;\n    }\n\n    public string GetInfo(){\n        return $"El total es {Total}";\n    }\n}\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c#"},"/*\nExiste distinta sintaxis para poder crear un objeto:\n*/\nSale sale = new Sale();\nvar sale2 = new Sale();\nSale sale3 = new();\n\nvar mySale = new Sale(19);\nConsole.WriteLine(mySale.GetInfo());\n")),(0,o.kt)("h3",{id:"herencia"},"Herencia"),(0,o.kt)("p",null,"Practicamente permite que una clase pueda reutilizar el codigo existente de otra clase."),(0,o.kt)("p",null,"Ejemplo, creando una clase que herede de la clase ",(0,o.kt)("inlineCode",{parentName:"p"},"Sale")," utilizada anteriormente"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c#"},"class SaleWithTax : Sale {\n    // base manda el parametro al constructor de la clase padre (Sale)\n    public SaleWithTax(decimal Total) : base(total){\n\n    }\n}\n\nvar saleWithTax = new SaleWithTax(10);\nsaleWithTax.GetInfo(); // Metodo heredado de la clase Sale\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Protected"),". Este modificador de acceso permite que las propiedades y metodos de la clase padre puedan usarse dentro de la case heredada pero sin que sean accesibles a traves del objeto. Es parecido a lo que haria el modificador ",(0,o.kt)("inlineCode",{parentName:"p"},"private")," pero permitiendo que se pueda heredar.")),(0,o.kt)("h3",{id:"sobreescritura--override"},"Sobreescritura / override"),(0,o.kt)("p",null,"En ocasiones el comportamiento heredado no es lo que necesitamos por lo que podemos sobreescribir los metodos que heredamos en una clase. Se utiliza la palabra reservada ",(0,o.kt)("inlineCode",{parentName:"p"},"virtual")," para indicar que es posible sobreescribir el metodo de la clase padre y desde la clase heredada se utiliza ",(0,o.kt)("inlineCode",{parentName:"p"},"override")," para indicar el nuevo comportamiento"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c#"},'class Sale{\n    public virtual string GetInfo (){return "Hello";}\n}\n\nclass SaleWithTax : Sale{\n    public override string GetInfo(){return "Hi!";}\n}\n')),(0,o.kt)("h2",{id:"interfaces"},"Interfaces"),(0,o.kt)("p",null,"Un interfaz en es una colecci\xf3n de definiciones que una clase o una estructura puede implementar (como m\xe9todos, propiedades, eventos o indexadores)."),(0,o.kt)("p",null,"A diferencia de las clases, los interfaces no contienen implementaciones de m\xe9todos, solo definen los miembros que deben ser implementados por las clases o estructuras que los implementan."),(0,o.kt)("p",null,"Las interfaces son un contrato que una clase puede firmar para indicar que implementar\xe1 ciertas funcionalidades y propiedades. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c#"},'interface ISale{\n    decimal Total {get; set;}\n}\n\ninterface ISave{\n    public void Save();\n}\n\npublic class Sale : ISale,ISave{\n    public decimal Total {get; set;}\n    public void Save(){\n        Console.WriteLine("Save");\n    }\n}\n\npublic class RandomClass : ISave{\n    public void Save(){\n        Console.WriteLine("Save method");\n    }\n}\n')),(0,o.kt)("p",null,"Gracias a las interfaces se pueden realizar metodos o funciones que esperen un objeto que cumpla con la interfaz, independiente de que clase provenga."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c#"},"var sale = new Sale();\nvar rClass = new RandomClass();\nvoid Some(ISave save){\n    // Do something\n}\n\nSome(sale);\nSome(rClass);\n")),(0,o.kt)("h2",{id:"generics"},"Generics"),(0,o.kt)("p",null,"Con Generics se pueden crear clases o m\xe9todos que son independientes de su tipo contenido. En vez de escribir m\xe9todos o clases con la misma funcionalidad para diferentes tipos, se puede crear \xfanicamente un m\xe9todo o una clase para ello."),(0,o.kt)("p",null,"Una clase gen\xe9rica se define una \xfanica vez y se puede reutilizar con cualquier tipo. Un ejemplo b\xe1sico es el de la clase List del espacio de nombres ",(0,o.kt)("inlineCode",{parentName:"p"},"System.Collections.Generic")," que se puede instanciar como una lista de enteros, de cadenas o de clases:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c#"},'var list = new List<int>();\nlist.Add(23);\n \nvar stringList = new List<string>();\nstringList.Add("mi cadena");\n \nvar miClaseList = new List<MiClase>();\nmiClaseList.Add(new MiClase());\n')),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Creando una clase generica")),(0,o.kt)("p",null,"Por convencion se utiliza como parametro de clase ",(0,o.kt)("inlineCode",{parentName:"p"},"<T>"),". ",(0,o.kt)("strong",{parentName:"p"},"T")," indica un Tipo de dato, no se especifica alguno en particular"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c#"},'public class MyList<T>{\n    private List<T> list;\n    private int _limit;\n\n    public MyList(int limit){\n        _limit = limit;\n        list = new List<T>();\n    }\n\n    public void Add(T element){\n        if(_list.Count < _limit){\n            _list.Add(element);\n        }\n    }\n}\n\nvar numbers = new MyList<int>(2);\nvar names = new MyList<string>(1);\n\nnumbers.Add(34);\nnumbers.Add(28);\nnumbers.Add(50); // La clase MyList no agregara el tercer elemento por fijar el limite en 2 elementos en el constructor\n\nnames.Add("Aitana");\nnames.Add("Daniela"); // No se agregara a la lista MyList<string>(1);\nnames.Add("Leo"); // No se agregara a la lista MyList<string>(1);\n')),(0,o.kt)("h2",{id:"serializacion-y-deserializacion-json"},"Serializacion y deserializacion (JSON)"),(0,o.kt)("p",null,"Utilizando la siguiente clase Persona, se pueden convertir instancias de clase al formato json(serializar) y viceversa, convertir formato json a instancias de objeto"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c#"},'using System.Text.Json;\n\nvar p1 = new People(){\n    Name = "Hedson",\n    Age = 24\n};\n\n// Serializar un objeto a formato JSON\nstring json = JsonSerializer.Serialize(p1);\nConsole.WriteLine(json);\n\n// Deserializar un formato Json a Objeto\nstring myJson = @" {""Name"":""Leonardo"",""Age"":25} ";\nPeople people = JsonSerializer.Deserialize<People>(myJson);\nConsole.WriteLine(people?.Name);\nConsole.WriteLine(people?.Age);\n\npublic class People{\n    public string Name {get; set;}\n    public int Age {get; set;}\n}\n\n')),(0,o.kt)("h2",{id:"programacion-funcional"},"Programacion Funcional"),(0,o.kt)("p",null,"\xbfQu\xe9 es la programaci\xf3n funcional en C#?"),(0,o.kt)("p",null,"La programaci\xf3n funcional es un paradigma de programaci\xf3n que se centra en el uso de funciones como bloques fundamentales para construir programas. "),(0,o.kt)("p",null,"En C#, aunque es un lenguaje orientado a objetos, tambi\xe9n permite la programaci\xf3n funcional mediante el uso de funciones de orden superior, expresiones lambda y la inmutabilidad de los datos. "),(0,o.kt)("p",null,"Caracter\xedsticas clave de la programaci\xf3n funcional en C#:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Funciones de orden superior:")," Estas son funciones que pueden recibir otras funciones como par\xe1metros o devolver funciones como resultado. Esto permite crear c\xf3digo m\xe1s modular y reutilizable."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Inmutabilidad:")," En la programaci\xf3n funcional, se prefiere no modificar los datos una vez que han sido creados. Esto ayuda a evitar efectos secundarios y hace que el c\xf3digo sea m\xe1s predecible y f\xe1cil de entender."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Expresiones lambda:")," C# permite el uso de expresiones lambda, que son una forma concisa de definir funciones an\xf3nimas. Esto facilita la escritura de c\xf3digo funcional, especialmente al trabajar con colecciones y LINQ."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Composici\xf3n de funciones:")," Se pueden combinar varias funciones para crear nuevas funciones, lo que permite construir soluciones complejas a partir de componentes m\xe1s simples.")),(0,o.kt)("h3",{id:"funcion-pura"},"Funcion Pura"),(0,o.kt)("p",null,"Una funci\xf3n pura es una funci\xf3n que siempre produce el mismo resultado cuando se llama con los mismos argumentos y que no tiene efectos secundarios, es decir, no modifica ni depende del estado externo."),(0,o.kt)("p",null,"Para que una funci\xf3n sea considerada como pura, debe cumplir con dos reglas fundamentales:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Dado el mismo conjunto de argumentos, la funci\xf3n siempre debe devolver el mismo resultado. Esto significa que la funci\xf3n no debe depender de ninguna variable o estado externo."),(0,o.kt)("li",{parentName:"ol"},"La funci\xf3n no debe tener efectos secundarios. Esto significa que la funci\xf3n no debe cambiar ning\xfan estado externo o interactuar con otras partes del sistema. La funci\xf3n solo debe realizar operaciones en los datos de entrada y devolver un resultado.")),(0,o.kt)("p",null,"Las funciones puras siempre devuelven el mismo resultado cuando reciben los mismos par\xe1metros. En cambio, otras funciones que dependen de factores externos (como el tiempo o una petici\xf3n HTTP) no siempre pueden devolver el mismo resultado aunque reciban los mismos par\xe1metros, incluso, pueden no necesitar recibir par\xe1metros para ejecutarse correctamente."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Ejemplo funcion pura")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const double = x => x*2\ndouble(2) // siempre es 4\ndouble(3) // siempre es 6\n\nconst isGreaterThan = (value, comparison) => value > comparison\nisGreaterThan(5, 6) // siempre devuelve false\nisGreaterThan(8, 6) // siempre devuelve true\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Ejemplo de funcion que no es pura")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const time = () => new Data().toLocalTimeString()\ntime() // siempre devuelve un resultado diferente\n")),(0,o.kt)("h3",{id:"funcion-de-primera-clase"},"Funcion de primera clase"),(0,o.kt)("p",null,'En C#, se dice que las funciones son de primera clase ("objetos de primera clase") cuando se pueden tratar como cualquier otro tipo de dato. Esto significa que puedes:'),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Asignar funciones a variables:")," Puedes almacenar una funci\xf3n en una variable, lo que te permite pasarla y utilizarla m\xe1s tarde."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Pasar funciones como argumentos:")," Puedes enviar funciones como par\xe1metros a otras funciones, lo que permite crear funciones m\xe1s flexibles y reutilizables."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Devolver funciones desde otras funciones:")," Puedes crear funciones que devuelvan otras funciones, lo que permite construir comportamientos din\xe1micos y complejos.")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Desde C# 3.0, se introdujeron tipos como ",(0,o.kt)("inlineCode",{parentName:"p"},"Func")," y ",(0,o.kt)("inlineCode",{parentName:"p"},"Action"),", que facilitan el uso de funciones de primera clase en el lenguaje. Esto permite a los desarrolladores aprovechar la programaci\xf3n funcional, haciendo que el c\xf3digo sea m\xe1s modular y expresivo.")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Si el metodo no retorna nada se utiliza ",(0,o.kt)("inlineCode",{parentName:"p"},"Action")," y si es una funcion que retorna valor se usa ",(0,o.kt)("inlineCode",{parentName:"p"},"Func"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c#"},'// Guardar Funcion en una variable\nvar showVar = Show;\nvar showUpperVar = ShowUpper;\nshowVar("Hi!");\n\n// Ejecutar un metodo enviando otro metodo como parametro\nSome(showVar,"Hello there");\n\n// Ejecutar una funcion enviando otra funcion como parametro\nConsole.WriteLine(Somefn(showUpperVar,"To upper!!!"));\n\nvoid Show(string message){\n    Console.WriteLine(message);\n}\n\nstring ShowUpper(string message){\n    return message.ToUpper();\n}\n\n// Se puede recibir un metodo como parametro, se utiliza el tipo Action en caso de que sea un metodo que no retorne nada, y se utiliza el generic <string> por que recibe ese valor para ejecutar el void\nvoid Some(Action<string> fn, string message){\n    Console.WriteLine("Proceso aqui");\n    fn(message);\n    Console.WriteLine("Proceso aqui");\n}\n\n// Se puede recibir una funcion como parametro, indicando lo que se recibe y retorna junto a la sentencia Func<recibe,retorna>\nstring Somefn(Func<string,string> fn, string message){\n    Console.WriteLine("Proceso aqui");\n    return fn(message);\n    Console.WriteLine("Proceso aqui");\n}\n')),(0,o.kt)("h2",{id:"expresiones-lambda"},"Expresiones Lambda"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"En algunos lenguajes pueden conocerse como funciones flecha, funci\xf3n literal o funci\xf3n an\xf3nima")),(0,o.kt)("p",null,"Las expresiones lambda en C# son una forma concisa de definir funciones an\xf3nimas. Una manera sencilla de conceptualizarlas es pensar en ellas como una forma de escribir m\xe9todos en una sola l\xednea. Por ejemplo, en lugar de definir un m\xe9todo completo, puedes usar una expresi\xf3n lambda para realizar una operaci\xf3n simple, como sumar dos n\xfameros o filtrar una lista"),(0,o.kt)("p",null,"Las expresiones lambda son especialmente \xfatiles en programaci\xf3n funcional y se utilizan com\xfanmente con m\xe9todos como Select, Where y otros que operan sobre colecciones. Esto permite escribir c\xf3digo m\xe1s limpio y legible, facilitando la manipulaci\xf3n de datos en colecciones y la implementaci\xf3n de l\xf3gica de negocio de manera m\xe1s directa."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c#"},"// La siguiente funcion lambda recibe dos numeros enteros y regresa uno.\nFunc<int,int,int> sub = (int a,int b) => a-b;\n\n// Se puede simplificar por que se indico los tipos de dato de las variables de entrada\nFunc<int,int,int> sub = (a,b) => a-b;\n\n// Sin una funcion lambda se tendria que crear una funcion como la siguiente\nint sub(int a, int b){\n    return a-b;\n}\n\n// Existe la posibilidad de escribir mas lineas de codigo en una funcion lambda\nFunc<int,int> some = a => {\n    a = a + 1;\n    return a * 5;\n};\n")),(0,o.kt)("h2",{id:"linq"},"LINQ"),(0,o.kt)("p",null,"LINQ, que significa ",(0,o.kt)("strong",{parentName:"p"},"Language Integrated Query"),", es un conjunto de tecnolog\xedas desarrolladas por Microsoft que permite realizar consultas y manipulaciones de datos de manera integrada en el lenguaje C#. Esta herramienta facilita la interacci\xf3n con diferentes fuentes de datos, como bases de datos, colecciones de objetos, XML, y m\xe1s, utilizando una sintaxis que es similar a SQL, pero que se integra directamente en el c\xf3digo C#"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c#"},'var names = new List<string>(){\n    "Hedson","Daniela","Aitana","Leo"\n};\n\n// Esta consulta no se ejecuta hasta que se haga uso de la variable namesFiltered\nvar namesFiltered = from n in names \n                    where n.Length > 3 && n.Length < 8\n                    orderby n descending\n                    select n;\n\n// Si se desea ejecutar directamente (Considerar que afecta al rendimiento)\nvar namesFiltered2 = (from n in names \n                    orderby n descending\n                    select n).ToList();\n\n// Las consultas son tratadas como funciones por el compilador, por lo que tambien es valido:\nvar namesFiltered3 = names.Where(n => n.Length>3 )\n                          .OrderByDescending(n => n)\n                          .Select(d => d);\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c#"},"var numeros = new List<int> { 1, 2, 3, 4, 5 };\nvar numerosPares = from n in numeros\n                   where n % 2 == 0\n                   select n;\n")))}p.isMDXComponent=!0}}]);